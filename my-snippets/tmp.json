{
	"Print to console": {
		"prefix": "tengh_edit",
		"body": [
			"",
			"//----------------",
			"//--Description: $1",
			"//--Edit by TengHao",
			"//--Date: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
			"$2"
		],
		"description": "Edited by Teng Hao + time"
	},
    "Print to console": {
		"prefix": "bitTree_template",
		"body": [
            "class BitTree {",
            "public:",
            "    vector<int> treesum;",
            "    int n;",
            "    BitTree() {}",
            "    BitTree(int n){",
            "        this->treesum.resize(n + 1, 0);",
            "        this->n = n;",
            "    }",
            "    int lowbit(int x){",
            "        return x & (-x);",
            "    }",
            "    ",
            "    void updata(int i, int diff){",
            "        while (i <= n) {",
            "            treesum[i] += diff; i += lowbit(i);",
            "        }",
            "    }",
            "    int query(int i){",
            "        int presum = 0;",
            "        while (i > 0){",
            "            presum += treesum[i]; i -= lowbit(i);",
            "        }",
            "        return presum;",
            "    }",
            "};",
            "",
            "class BitTree_max {",
            "  public:",
            "    int n;",
            "    vector<int> h;",
            "    BitTree_max() {}",
            "    BitTree_max(int n) {",
            "        this->h.resize(n + 1, 0);",
            "        this->n = n;",
            "    }",
            "    int lowbit(int x) { return x & (-x); }",
            "",
            "    //仅适用于递增的更新 ？a[i] 变大 ",
            "    // void updata(int i, int val) {",
            "    //     while (i <= n) {",
            "    //         h[i] = max(h[i], val);",
            "    //         i += lowbit(i);",
            "    //     }",
            "    // }",
            "",
            "    //同时使用与递增递减的更新",
            "    void updata(int x) {",
            "        int lx;",
            "        for (; x <= this->n; x += lowbit(x)) {",
            "            h[x] = arr[x];",
            "            lx = lowbit(x);",
            "            for (int i = 1; i < lx; i <<= 1)",
            "                h[x] = max(h[x], h[x - i]);",
            "        }",
            "    }",
            "",
            "    // int query(int x) {",
            "    //     int ans = 0;",
            "    //     for (int i = x; i > 0; i -= lowbit(i)){",
            "    //         ans = max(h[i], ans);",
            "    //     }",
            "    //     return ans;",
            "    // }",
            "    //  arr 是待求的数组",
            "    int query(int x, int y) {",
            "        int ans = 0;",
            "        while (y >= x) {",
            "            ans = max(arr[y], ans);",
            "            y--;",
            "            for (; y - lowbit(y) >= x; y -= lowbit(y))",
            "                ans = max(h[y], ans);",
            "        }",
            "        return ans;",
            "    }",
            "};"

		],
		"description": "cpp template"
	},
    "Print to console": {
		"prefix": "inv_C_template",
		"body": [
            "",
            "const int mxN = 2e6 + 10;",
            "const int MOD = 1e9 + 7;",
            "ll qpow(ll a, ll b) {",
            "    ll ans = 1;",
            "    a %= MOD;",
            "    while (b) {",
            "        if (b & 1) ans = ans * a % MOD;",
            "        a = a * a % MOD;",
            "        b >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "ll get_inv(ll x) { return qpow(x, MOD - 2); }",
            "// ll fac[mxN], invfac[mxN];",
            "// void init_fac_inv(int n) {",
            "//     fac[0] = 1;",
            "//     for (int i = 1; i <= n; i++) {",
            "//         fac[i] = fac[i - 1] * i % MOD;",
            "//     }",
            "//     invfac[n] = get_inv(fac[n]);",
            "//     for (int i = n; i; i--) {",
            "//         invfac[i - 1] = invfac[i] * i % MOD;",
            "//     }",
            "// }",
            "// ll C(ll m, ll n) {",
            "//     if (m > n || m < 0) return 0;",
            "//     return fac[n] * invfac[m] % MOD * invfac[n-m] % MOD;",
            "// }"
		],
		"description": "cpp template"
	},
    "Print to console": {
		"prefix": "str_hash_template",
		"body": [
            "typedef unsigned long long ULL;",
            "const int mxN = 100010; // 字符串最大长度",
            "const int P = 131;",
            "// p[i] = P^i, h[i]=s[1~i]的hash值",
            "ULL p[mxN], h[mxN];",
            "string s; // 预处理字符串，下标从1开始！！！",
            "int n; // 字符串长度 1~n",
            "//预处理hash函数的前缀和",
            "void init() {",
            "    p[0] = 1, h[0] = 0;",
            "    for (int i = 1; i <= n; i++) {",
            "        p[i] = p[i - 1] * P;",
            "        h[i] = h[i - 1] * P + s[i];",
            "    }",
            "}",
            "// 计算s[l~r]的hash值",
            "ULL get(int l, int r) {",
            "    return h[r] - h[l - 1] * p[r - l + 1];",
            "}",
            "// 判断两子串是否相等",
            "bool substr(int l1, int r1, int l2, int r2) {",
            "    return get(l1, r1) == get(l2, r2);",
            "}"
		],
		"description": "cpp template"
	}

}





