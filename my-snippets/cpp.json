{
	"Print to console": {
		"prefix": "tengh_edit",
		"body": [
			"",
			"//----------------",
			"//--Description: $1",
			"//--Edit by TengHao",
			"//--Date: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
			"$2"
		],
		"description": "Edited by Teng Hao + time"
	},
    "bitTree sum template": {
		"prefix": "bitTree_template",
		"body": [
            "class BitTree {",
            "public:",
            "    vector<int> treesum;",
            "    int n;",
            "    BitTree() {}",
            "    BitTree(int n){",
            "        this->treesum.resize(n + 1, 0);",
            "        this->n = n;",
            "    }",
            "    int lowbit(int x){",
            "        return x & (-x);",
            "    }",
            "    void updata(int i, int diff){",
            "        while (i <= n) {",
            "            treesum[i] += diff; i += lowbit(i);",
            "        }",
            "    }",
            "    int query(int i){",
            "        int presum = 0;",
            "        while (i > 0){",
            "            presum += treesum[i]; i -= lowbit(i);",
            "        }",
            "        return presum;",
            "    }",
            "};",
            "",
            ""
		],
		"description": "cpp template"
	},
    "bitTree max template": {
		"prefix": "bitTree_max_template",
		"body": [
            "",
            "class BitTree_max {",
            "  public:",
            "    int n;",
            "    vector<int> h;",
            "    BitTree_max() {}",
            "    BitTree_max(int n) {",
            "        this->h.resize(n + 1, 0); // 最小值为0,没有负数",
            "        this->n = n;",
            "    }",
            "    int lowbit(int x) { return x & (-x); }",
            "    //仅适用于递增的更新 ？a[i] 变大 ",
            "    // void updata(int i, int val) {",
            "    //     while (i <= n) {",
            "    //         h[i] = max(h[i], val);",
            "    //         i += lowbit(i);",
            "    //     }",
            "    // }",
            "    //同时使用与递增递减的更新",
            "    void updata(int x) {",
            "        int lx;",
            "        for (; x <= this->n; x += lowbit(x)) {",
            "            h[x] = arr[x];",
            "            lx = lowbit(x);",
            "            for (int i = 1; i < lx; i <<= 1)",
            "                h[x] = max(h[x], h[x - i]);",
            "        }",
            "    }",
            "    // int query(int x) {",
            "    //     int ans = 0;",
            "    //     for (int i = x; i > 0; i -= lowbit(i)){",
            "    //         ans = max(h[i], ans);",
            "    //     }",
            "    //     return ans;",
            "    // }",
            "    //  arr 是待求的数组",
            "    int query(int x, int y) {",
            "        int ans = 0; // 最小值为0,没有负数",
            "        while (y >= x) {",
            "            ans = max(arr[y], ans);",
            "            y--;",
            "            for (; y - lowbit(y) >= x; y -= lowbit(y))",
            "                ans = max(h[y], ans);",
            "        }",
            "        return ans;",
            "    }",
            "};",
            "",
            ""
		],
		"description": "cpp template"
	},
    "bitTree min template": {
		"prefix": "bitTree_min_template",
		"body": [
            "",
            "class BitTree_min {",
            "  public:",
            "    int n;",
            "    vector<int> h;",
            "    vector<int> arr;",
            "    BitTree_min() {}",
            "    BitTree_min(int n) {",
            "        this->h.resize(n + 2, INT_MAX);",
            "        this->n = n;",
            "        this->arr.resize(n + 1);",
            "    }",
            "    int lowbit(int x) { return x & (-x); }",
            "    void updata(int x) {",
            "        int lx;",
            "        for (; x <= this->n; x += lowbit(x)) {",
            "            h[x] = arr[x];",
            "            lx = lowbit(x);",
            "            for (int i = 1; i < lx; i <<= 1)",
            "                h[x] = min(h[x], h[x - i]);",
            "        }",
            "    }",
            "    int query(int x, int y) {",
            "        int ans = INT_MAX;",
            "        while (y >= x) {",
            "            ans = min(arr[y], ans);",
            "            y--;",
            "            for (; y - lowbit(y) >= x; y -= lowbit(y))",
            "                ans = min(h[y], ans);",
            "        }",
            "        return ans;",
            "    }",
            "};",
            "",
            ""
		],
		"description": "cpp template"
	},
    "inv C template": {
		"prefix": "inv_C_template",
		"body": [
            "const int mxN = 2e6 + 10;",
            "const int MOD = 1e9 + 7;",
            "ll qpow(ll a, ll b) {",
            "    ll ans = 1;",
            "    a %= MOD;",
            "    while (b) {",
            "        if (b & 1) ans = ans * a % MOD;",
            "        a = a * a % MOD;",
            "        b >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "ll get_inv(ll x) { return qpow(x, MOD - 2); }",
            "// ll fac[mxN], invfac[mxN];",
            "// void init_fac_inv(int n) {",
            "//     fac[0] = 1;",
            "//     for (int i = 1; i <= n; i++) {",
            "//         fac[i] = fac[i - 1] * i % MOD;",
            "//     }",
            "//     invfac[n] = get_inv(fac[n]);",
            "//     for (int i = n; i; i--) {",
            "//         invfac[i - 1] = invfac[i] * i % MOD;",
            "//     }",
            "// }",
            "// ll C(ll n, ll m) {",
            "//     if (m > n || m < 0) return 0;",
            "//     return fac[n] * invfac[m] % MOD * invfac[n-m] % MOD;",
            "// }",
            "",
            ""
		],
		"description": "cpp template"
	},
    "str hash template": {
		"prefix": "str_hash_template",
		"body": [
            "typedef unsigned long long ULL;",
            "const int mxN = 100010; // 字符串最大长度",
            "const int P = 131;",
            "// p[i] = P^i, h[i]=s[1~i]的hash值",
            "ULL p[mxN], h[mxN];",
            "string s; // 预处理字符串，下标从1开始！！！",
            "int n; // 字符串长度 1~n",
            "//预处理hash函数的前缀和",
            "void init() {",
            "    p[0] = 1, h[0] = 0;",
            "    for (int i = 1; i <= n; i++) {",
            "        p[i] = p[i - 1] * P;",
            "        h[i] = h[i - 1] * P + s[i];",
            "    }",
            "}",
            "// 计算s[l~r]的hash值",
            "ULL get(int l, int r) {",
            "    return h[r] - h[l - 1] * p[r - l + 1];",
            "}",
            "// 判断两子串是否相等",
            "bool substr(int l1, int r1, int l2, int r2) {",
            "    return get(l1, r1) == get(l2, r2);",
            "}",
            "",
            ""
		],
		"description": "cpp template"
	},
    "segment tree sum": {
		"prefix": "segTree_sum_template",
		"body": [
            "class segTree_sum {",
            "public:",
            "    struct node {",
            "        int l, r; ll sum, add;",
            "    };",
            "    vector<node> tr;",
            "    segTree_sum() { cout << \"tr is empty!\" << endl;}",
            "    segTree_sum(int n) {",
            "        tr.resize(4 * (n+1));",
            "    }",
            "    void pushup(int p) {",
            "        tr[p].sum = tr[p << 1].sum + tr[p << 1 | 1].sum;",
            "    }",
            "    void pushdown(int p) {",
            "        if (tr[p].add) {",
            "            auto &l = tr[p << 1], &r = tr[p << 1 | 1];",
            "            l.sum += tr[p].add * (l.r - l.l + 1);",
            "            r.sum += tr[p].add * (r.r - r.l + 1);",
            "            l.add += tr[p].add;",
            "            r.add += tr[p].add;",
            "            tr[p].add = 0;",
            "        }",
            "    }",
            "    template<typename M>",
            "    void build(int p, int l, int r, vector<M> &w) {",
            "        tr[p] = {l, r, w[l], 0};",
            "        if (l == r) return; // 是叶子则返回",
            "        int mid = l + ((r - l) >> 1); // 不是叶子则裂开",
            "        build(p << 1, l, mid, w);",
            "        build(p << 1 | 1, mid + 1, r, w);",
            "        pushup(p);",
            "    }",
            "    // 单点更改",
            "    // void update(int p, int x, int k) {",
            "    //     if (tr[p].l == x && tr[p].r == x) {",
            "    //         tr[p].sum += k;",
            "    //         return;",
            "    //     }",
            "    //     int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1);",
            "    //     if (x <= mid) update(p << 1, x, k);",
            "    //     if (x > mid) update(p << 1 | 1, x, k);",
            "    //     pushup(p);",
            "    // }",
            "    // 区间更改",
            "    void update(int p, int x, int y, int k) {",
            "        if (x <= tr[p].l && tr[p].r <= y) { // 覆盖则修改",
            "            tr[p].sum += (ll)(tr[p].r - tr[p].l + 1) * k;",
            "            tr[p].add += k;",
            "            return;",
            "        }",
            "        int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1); // 不覆盖则裂开",
            "        pushdown(p);",
            "        if (x <= mid) update(p << 1, x, y, k);",
            "        if (y > mid) update(p << 1 | 1, x, y, k);",
            "        pushup(p);",
            "    }",
            "    ll query(int p, int x, int y) {",
            "        if (x <= tr[p].l && tr[p].r <= y) return tr[p].sum; // 覆盖则返回",
            "        int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1); // 不覆盖则裂开",
            "        pushdown(p);",
            "        ll sum = 0;",
            "        if (x <= mid) sum += query(p << 1, x, y);",
            "        if (y > mid) sum += query(p << 1 | 1, x, y);",
            "        return sum;",
            "    };",
            "};"
		],
		"description": "cpp template"
	},
    "segment tree max": {
		"prefix": "segTree_max_template",
		"body": [
            "class segTree_max {",
            "public:",
            "    struct node {",
            "        int l, r; ",
            "        ll val, add;",
            "    };",
            "    vector<node> tr;",
            "    segTree_max() { cout << \"tr is empty!\" << endl;}",
            "    segTree_max(int n) {",
            "        tr.resize(4 * (n+1));",
            "    }",
            "    void pushup(int p) {",
            "        tr[p].val = max(tr[p << 1].val, tr[p << 1 | 1].val);",
            "    }",
            "    void pushdown(int p) {",
            "        if (tr[p].add) {",
            "            tr[p << 1].val += tr[p].add;",
            "            tr[p << 1 | 1].val += tr[p].add;",
            "            tr[p << 1].add += tr[p].add;",
            "            tr[p << 1 | 1].add += tr[p].add;",
            "            tr[p].add = 0;",
            "        }",
            "    }",
            "    template <typename M>",
            "    void build(int p, int l, int r, vector<M> &w) {",
            "        tr[p] = {l, r, w[l], 0}; ",
            "        if (l == r) return;",
            "        int mid = l + ((r - l) >> 1);",
            "        build(p << 1, l, mid, w);",
            "        build(p << 1 | 1, mid + 1, r, w);",
            "        pushup(p);",
            "    }",
            "    // 区间更改",
            "    void update(int p, int x, int y, int k) {",
            "        if (x <= tr[p].l && tr[p].r <= y) {",
            "            tr[p].val += k;",
            "            tr[p].add += k;",
            "            return;",
            "        }",
            "        int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1);",
            "        pushdown(p);",
            "        if (x <= mid) update(p << 1, x, y, k);",
            "        if (y > mid) update(p << 1 | 1, x, y, k);",
            "        pushup(p);",
            "    }",
            "    ll query(int p, int x, int y) {",
            "        if (x <= tr[p].l && tr[p].r <= y) return tr[p].val;",
            "        int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1);",
            "        pushdown(p);",
            "        ll ans = INT_MIN;",
            "        if (x <= mid) ans = max(ans, query(p << 1, x, y));",
            "        if (y > mid) ans = max(ans, query(p << 1 | 1 , x, y));",
            "        tr[p].val = max(tr[p << 1].val, tr[p << 1 | 1].val);",
            "        return ans;",
            "    }",
            "};"
		],
		"description": "cpp template"
	},
    "segment tree min": {
		"prefix": "segTree_min_template",
		"body": [
            "class segTree_min {",
            "public:",
            "    struct node {",
            "        int l, r; ll val, add;",
            "    };",
            "    vector<node> tr;",
            "    segTree_min() { cout << \"tr is empty!\" << endl;}",
            "    segTree_min(int n) {",
            "        tr.resize(4 * (n+1));",
            "    }",
            "    void pushup(int p) {",
            "        tr[p].val = min(tr[p << 1].val, tr[p << 1 | 1].val);",
            "    }",
            "    void pushdown(int p) {",
            "        if (tr[p].add) {",
            "            tr[p << 1].val += tr[p].add;",
            "            tr[p << 1 | 1].val += tr[p].add;",
            "            tr[p << 1].add += tr[p].add;",
            "            tr[p << 1 | 1].add += tr[p].add;",
            "            tr[p].add = 0;",
            "        }",
            "    }",
            "    template <typename M>",
            "    void build(int p, int l, int r, vector<M> &w) {",
            "        tr[p] = {l, r, w[l], 0}; ",
            "        if (l == r) return;",
            "        int mid = l + ((r - l) >> 1);",
            "        build(p << 1, l, mid, w);",
            "        build(p << 1 | 1, mid + 1, r, w);",
            "        pushup(p);",
            "    }",
            "    // 区间更改",
            "    void update(int p, int x, int y, int k) {",
            "        if (x <= tr[p].l && tr[p].r <= y) {",
            "            tr[p].val += k;",
            "            tr[p].add += k;",
            "            return;",
            "        }",
            "        int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1);",
            "        pushdown(p);",
            "        if (x <= mid) update(p << 1, x, y, k);",
            "        if (y > mid) update(p << 1 | 1, x, y, k);",
            "        pushup(p);",
            "    }",
            "    ll query(int p, int x, int y) {",
            "        if (x <= tr[p].l && tr[p].r <= y) return tr[p].val;",
            "        int mid = tr[p].l + ((tr[p].r - tr[p].l) >> 1);",
            "        pushdown(p);",
            "        ll ans = INT_MAX;",
            "        if (x <= mid) ans = min(ans, query(p << 1, x, y));",
            "        if (y > mid) ans = min(ans, query(p << 1 | 1 , x, y));",
            "        return ans;",
            "    }",
            "};"
		],
		"description": "cpp template"
	}





}





